package com.github.sun5066.entity_mapper

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import java.io.OutputStream

private fun OutputStream.appendLine(str: String) {
    this.write((str + "\n").toByteArray())
}

class EntityMapperProcessor(
    private val codeGenerator: CodeGenerator,
    private val logger: KSPLogger
) : SymbolProcessor {

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val symbols = resolver.getSymbolsWithAnnotation(EntityMapper::class.qualifiedName!!)
        val ret = symbols.filterNot { it.validate() }.toList()

        symbols.filterIsInstance<KSClassDeclaration>()
            .filter { it.validate() }
            .forEach { it.accept(MapperVisitor(), Unit) }

        return ret
    }

    inner class MapperVisitor : KSVisitorVoid() {
        override fun visitClassDeclaration(classDeclaration: KSClassDeclaration, data: Unit) {
            classDeclaration.annotations.firstOrNull {
                it.shortName.asString() == EntityMapper::class.simpleName
            }?.arguments?.find {
                it.name?.asString() == "fromClass"
            }?.value?.let { from ->
                (from as? KSType)?.also { fromClassType ->
                    val fromClassDeclaration = fromClassType.declaration as? KSClassDeclaration ?: return
                    generateMappingFunction(classDeclaration, fromClassDeclaration)
                }
            }
        }

        private fun generateMappingFunction(targetClass: KSClassDeclaration, fromClass: KSClassDeclaration) {
            val targetClassName = targetClass.simpleName.asString()
            val fromClassName = fromClass.simpleName.asString()
            val packageName = targetClass.packageName.asString()
            val fileName = "AutoGenerated_${fromClassName}To${targetClassName}Mapper"

            codeGenerator.createNewFile(
                Dependencies(true, targetClass.containingFile!!),
                packageName,
                fileName
            ).use { writer ->
                writer.appendLine("package $packageName\n")
                writer.appendLine("import ${fromClass.packageName.asString()}.$fromClassName\n")
                writer.appendLine("fun $fromClassName.to$targetClassName(): $targetClassName = $targetClassName(")

                val targetProperties = targetClass.getAllProperties()
                val listIndex = targetProperties.count()
                targetProperties.forEachIndexed { index, targetProperty ->
                    val targetPropertyName = targetProperty.simpleName.asString()
                    val sourcePropertyName = targetProperty.findSourcePropertyName(fromClass)

                    if (sourcePropertyName != null) {
                        val fromProperty = fromClass.getAllProperties().firstOrNull { it.simpleName.asString() == sourcePropertyName }

                        fromProperty?.let {
                            val conversionCode = generatePropertyConversionCode(it, targetProperty)
                            val comma = if (listIndex - 1 == index) "" else ","
                            writer.appendLine("    $targetPropertyName = $conversionCode$comma")
                        }
                    }
                }

                writer.appendLine(")")
            }
        }

        private fun generatePropertyConversionCode(fromProperty: KSPropertyDeclaration, targetProperty: KSPropertyDeclaration): String {
            val targetType = targetProperty.type.resolve()
            val fromType = fromProperty.type.resolve()
            val isTargetTypeList = targetType.declaration.simpleName.asString() == "List"
            val isEntity = fromType.declaration.simpleName.asString().contains("Entity", true)
            val isEntityList = isTargetTypeList && fromType.arguments.firstOrNull()?.type?.resolve().toString().contains("Entity")
            val isNullableTarget = targetType.nullability == Nullability.NULLABLE
            val isNullableFrom = fromType.nullability == Nullability.NULLABLE
            val fromPropertyName = fromProperty.simpleName.asString()

            return when {
                isTargetTypeList && !isEntityList && isNullableFrom && !isNullableTarget -> "this.$fromPropertyName ?: emptyList()"
                isTargetTypeList && isEntityList && isNullableFrom && !isNullableTarget -> "this.$fromPropertyName?.map { it.to${targetType.arguments.firstOrNull()?.type?.resolve()?.declaration?.simpleName?.asString()}() } ?: emptyList()"
                isTargetTypeList && isEntityList -> "this.$fromPropertyName.map { it.to${targetType.arguments.firstOrNull()?.type?.resolve()?.declaration?.simpleName?.asString()}() }"
                !isTargetTypeList && isEntity && isNullableFrom && !isNullableTarget -> "this.${fromPropertyName}!!.to${targetType.declaration.simpleName.asString()}()"
                !isTargetTypeList && isEntity && isNullableFrom && isNullableTarget -> "this.${fromPropertyName}?.to${targetType.declaration.simpleName.asString()}()"
                !isTargetTypeList && isEntity && !isNullableFrom && !isNullableTarget -> "this.${fromPropertyName}.to${targetType.declaration.simpleName.asString()}()"
                isNullableFrom && !isNullableTarget -> "this.${fromPropertyName}!!"
                else -> "this.${fromPropertyName}"
            }
        }

        private fun KSPropertyDeclaration.findSourcePropertyName(fromClass: KSClassDeclaration): String? {
            val targetPropertyName = this.simpleName.asString()
            val propertyAnnotation = this.annotations.firstOrNull { it.shortName.asString() == PropertyName::class.simpleName }

            if (propertyAnnotation != null) {
                val aliases = propertyAnnotation.arguments.firstOrNull { it.name?.asString() == "aliases" }?.value as List<String>

                aliases.forEach { alias ->
                    fromClass.getAllProperties().firstOrNull { it.simpleName.asString() == alias }?.let { return alias }
                }
            }

            return fromClass.getAllProperties().firstOrNull { it.simpleName.asString() == targetPropertyName }?.simpleName?.asString()
        }
    }
}
